# [项目1](https://github.com/ExFly/CsLearning/blob/master/Language/ASM/holiday/p1/p1.asm) 2017.01.16

第一天，开始的时候忘记计算一个段的大小，导致蒙蔽的开始用dup填充数据，妄想填充到0b800h哪里，显然无能为力。
之后，想到其实cs自动定位到第一个段，数据 即 程序，程序也可为数据，便想到，先写正常程序，编译后将数据填充到数据段中，完成程序后删除code段。
然后，填充的时候，填充数据填充少了一位，(相当于推出代码int 0)，导致出现其他字符。![img](p1/1.png)
解决如上问题，终于完成。
再次验证，设计论证的重要性！效率在哪里！！！
代码如下:
```asm
data segment
	dw 00b8h,8eb8h,0bbd8h,07cah,07c7h,0241h,00b8h, 0cd4ch, 0021h
data ends
```
等价于
```asm
assume cs:code
code segment
	mov ax,0b800h
	mov ds,ax
	mov bx,0a0h*12+25h*2
	mov word ptr ds:[bx],0241h
	
	mov ax,4c00h
	int 21h
code ends
```

# [项目2](https://github.com/ExFly/CsLearning/blob/master/Language/ASM/holiday/p2/p2.asm) 2017.01.17
* 没有挑战性

![img2](p2/1.png) ![img1](p2/result.png)

# [项目3](https://github.com/ExFly/CsLearning/blob/master/Language/ASM/holiday/p3/p3.asm) 2017.01.18
* 学了一个指令 jcxz (cx)==0时跳转，再也不用loop做跳转了
* 没挑战性

![img3](p3/1.png)

# [项目4](https://github.com/ExFly/CsLearning/blob/master/Language/ASM/holiday/p4/p41.asm) 2017.01.19
* 算数得到结果比较简单，但是64的输出有点难度。解决办法是通过除10取余数，并push余数，当商为0时，可以确认已经将所有位处理过，将结果出栈，放到显存相应位置就好了，
* jcxz配合jmp超好用。

![img4](p4/1.png)

# 计划
* 抽时间学一下call和ret
	* 有了函数调用，才真正实现了程序的模块化，所以把call ret学一下，以后用起来也方便
